################################################################################
# varioFunc = function(theta, D.hat){ 2*(D.hat/theta[1])^theta[2] }
simulMSP = function(s_in, range, dof, D, Trep, B){
  npro = nrow(D)
  vario = 2*(D/range)^dof
  semivario = vario/2
  dist2ori = sapply(1:npro, function(ii) norm(s_in[ii,], "2")) # origin is zero
  semivario2ori = (dist2ori/range)^dof
  covmat = matrix(semivario2ori, npro, npro) +
    matrix(semivario2ori, npro, npro, byrow = T) - semivario
  diag(covmat) = 2*semivario2ori + 1e-8
  
  Z.sim <- sapply(1:Trep, function(n){
    # print(n)
    PPPn <- cumsum(rexp(B))
    iPPPn = -log(PPPn)
    GPn = t(rmvnorm(n=B, mean=rep(0, npro), sigma=covmat, method="chol"))
    logZn = apply(sapply(1:B, function(b){GPn[,b] - semivario2ori + iPPPn[b]}), 1, max)
    return(exp(logZn))})
  
  Z.sim
}


simulrPareto <- function(n, loc, range, dof, D, risk, siteindex = NULL, nCores = 1, cl = NULL){
  # n = trep; loc = data.frame(swarped)
  # phi = phi; kappa = kappa
  # D = as.matrix(dist(swarped))
  # nCores = 1; cl = NULL
  
  if(!inherits(loc, "data.frame")) {
    stop('loc must be the data frame of coordinates as generated by expand.grid()')
  }
  
  dim <- nrow(loc)
  
  if(!is.numeric(nCores) || nCores < 1) {
    stop('`nCores`` must a positive number of cores to use for parallel computing.')
  }
  if(nCores > 1 && !inherits(cl, "cluster")) {
    stop('For parallel computation, `cl` must an cluster created by `makeCluster` of the package `parallel`.')
  }
  
  # semivario
  gamma <- tryCatch({
    (D/range)^dof # 0.5*
  }, warning = function(war) {
    war
  }, error = function(err) {
    stop('The semi-variogram provided is not valide for the provided locations.')
  })
  
  # ----------------------------------------------------------------------------
  # ref point for the cov and the var are different
  # k <- sample(1:dim, n, replace = TRUE)
  d <- nrow(gamma)
  
  # gamma[-1,1] = gamma[,1][-1]
  cov.mat <- (outer(gamma[-1,1],gamma[-1,1], "+") - (gamma[-1,-1]))
  chol.mat <- chol(cov.mat)
  
  # proc <- matrix(0,d,n)
  # proc[-1,] <- t(chol.mat)%*%matrix(rnorm((d-1)*n), ncol=n)
  # sims <- lapply(1:n, function(i){
  #   print(i)
  #   buffer <- exp(proc[,i] - proc[k[i],i] - gamma[,k[i]])
  #   proc[,i] <- evd::rgpd(1, loc=1, scale=1, shape=1) * buffer / risk(buffer) # mean
  #   proc[proc == 0] = 1e-37 # .Machine$double.xmin
  #   proc[,i]
  # })
  
  if (risk == "site") {
    GP <- matrix(0,d,n)
    GP[-1,] <- t(chol.mat)%*%matrix(rnorm((d-1)*n), ncol=n)
    sims = matrix(NaN, nrow = nrow(loc), ncol = n)
    
    for (i in 1:n){
      # print(i)
      W <- exp(GP[,i] - GP[siteindex,i] - gamma[,siteindex])
      Z <- evd::rgpd(1, loc=1, scale=1, shape=1) * W
      Z[Z == 0] = .Machine$double.xmin
      
      sims[,i] = Z
    }
  } else if (risk == "mean") {
    k = sample(1:dim, n, replace = TRUE)
    GP <- matrix(0,d,n)
    GP[-1,] <- t(chol.mat)%*%matrix(rnorm((d-1)*n), ncol=n)
    sims = matrix(NaN, nrow = nrow(loc), ncol = n)
    
    for (i in 1:n){
      # print(i)
      W <- exp(GP[,i] - GP[k[i],i] - gamma[,k[i]])
      Z <- evd::rgpd(1, loc=1, scale=1, shape=1) * W / mean(W)
      Z[Z == 0] = .Machine$double.xmin
      
      sims[,i] = Z
    }
  } else if (risk == "sum") { 
    # rejection method
    k = sample(1:dim, n, replace = TRUE)
    sims = matrix(NaN, nrow = nrow(loc), ncol = n)
    
    for (i in 1:n){
      # print(i)
      Z = rep(0, nrow(loc)); M = nrow(loc)
      while (sum(Z)<M) {
        GP <- numeric(d)
        GP[-1] <- t(chol.mat)%*%rnorm(d-1)
        W <- exp(GP - GP[k[i]] - gamma[,k[i]])
        Z <- evd::rgpd(1, loc=1, scale=1, shape=1) * W / mean(W)
        Z[Z == 0] = .Machine$double.xmin
      }
      
      sims[,i] = Z/M
    }
  } else if (risk == "max") { 
    # rejection method
    k = sample(1:dim, n, replace = TRUE)
    sims = matrix(NaN, nrow = nrow(loc), ncol = n)
    
    for (i in 1:n){
      # print(i)
      Z = rep(0, nrow(loc)); M = nrow(loc)
      while ((sum(Z^20)^{1/20})<M) {
        GP <- numeric(d)
        GP[-1] <- t(chol.mat)%*%rnorm(d-1)
        W <- exp(GP - GP[k[i]] - gamma[,k[i]])
        Z <- evd::rgpd(1, loc=1, scale=1, shape=1) * W / mean(W)
        Z[Z == 0] = .Machine$double.xmin
      }
      
      sims[,i] = Z/M
    }
  }
  return(sims)
}


################################################################################

scal_0_5_mat <- function(s) {
  mins <- matrix(1, nrow(s), 1) %*% apply(s, 2, min)
  maxs <- matrix(1, nrow(s), 1) %*% apply(s, 2, max)
  s <- (s - mins) / (maxs - mins) - 0.5
}

sim_data <- function(type = "Identical", model = "MSP-BR", ds = 0.001, n_obs = 300L, 
                     trep = 1L, phi = 0.1, kappa = 1, risk = "site", siteindex = NULL, 
                     space_seed = 7, data_seed = 1, nCores = 1, cl = NULL) {
  # ds = 0.1; r = riskFun; phi = 0.1; kappa = 1
  
  library(mvtnorm)
  library(fields)
  # type = type; model = model; ds = 0.01; n_obs = n_obs; trep = 1L; phi = 0.1; kappa = 1; r = riskFun
  
  s <- as.matrix(expand.grid(seq(-0.5, 0.5, by = ds), seq(-0.5, 0.5, by = ds)))
  swarped <- s
  
  LFT.pmt = NA
  eta = NA
  
  ## Simulate through process
  
  if(type == "Identical") {
    s_in = s
  } else if(type %in% c("AWU_RBF_2D", "AWU_RBF_LFT_2D")) {
    
    r1 <- 50
    
    if (type == "AWU_RBF_2D") {
      layers <- c(AWU(r = r1, dim = 1L, grad = 200, lims = c(-0.5, 0.5)),
                  AWU(r = r1, dim = 2L, grad = 200, lims = c(-0.5, 0.5)),
                  RBF_block(res = 1L))
    } else if (type == "AWU_RBF_LFT_2D") {
      set.seed(space_seed-3)
      a <- rnorm(1) + rnorm(1)*1i
      b <- rnorm(1) + rnorm(1)*1i
      c <- (rnorm(1) + rnorm(1)*1i)
      d <- (rnorm(1) + rnorm(1)*1i)
      LFT.pmt = list(a, b, c, d)
      stopifnot((Re(-d/c) < -0.5 | Re(-d/c) > 0.5 | Im(-d/c) < -0.5 | Im(-d/c) > 0.5))
      layers <- c(AWU(r = r1, dim = 1L, grad = 200, lims = c(-0.5, 0.5)),
                  AWU(r = r1, dim = 2L, grad = 200, lims = c(-0.5, 0.5)),
                  RBF_block(res = 1L),
                  LFT(a = c(a,b,c,d)))
    }
    nlayers <- length(layers)
    
    eta <- list()
    set.seed(space_seed)
    eta[[1]] <- sin(seq(0, pi, length.out = r1))
    eta[[2]] <- c(1, rep(0, r1-1))
    eta_RBF = runif(n = 9, min = -1, max = exp(3/2)/2)
    # print(eta_RBF)
    for(j in 3:11) eta[[j]] <- eta_RBF[j-2]
    
    # swarped <- s
    for(i in 1: (nlayers)){ # nlayers - 1 ???
      if (layers[[i]]$name == "LFT") {
        swarped <- layers[[i]]$fR(swarped, LFT.pmt) %>% scal_0_5_mat()
      } else { swarped <- layers[[i]]$fR(swarped, eta[[i]]) %>% scal_0_5_mat() }
    }
    
    s_in = swarped
  }  else if(type %in% c("AWU_RBF2_2D", "AWU_RBF2_LFT_2D")) {
    
    r1 <- 50
    if (type == "AWU_RBF2_2D") {
      layers <- c(AWU(r = r1, dim = 1L, grad = 200, lims = c(-0.5, 0.5)),
                  AWU(r = r1, dim = 2L, grad = 200, lims = c(-0.5, 0.5)),
                  RBF_block(res = 1L),
                  RBF_block(res = 2L))
    } else if (type == "AWU_RBF2_LFT_2D") {
      set.seed(space_seed-3)
      a <- rnorm(1) + rnorm(1)*1i
      b <- rnorm(1) + rnorm(1)*1i
      c <- (rnorm(1) + rnorm(1)*1i)
      d <- (rnorm(1) + rnorm(1)*1i)
      LFT.pmt = list(a, b, c, d)
      stopifnot((Re(-d/c) < -0.5 | Re(-d/c) > 0.5 | Im(-d/c) < -0.5 | Im(-d/c) > 0.5))
      layers <- c(AWU(r = r1, dim = 1L, grad = 200, lims = c(-0.5, 0.5)),
                  AWU(r = r1, dim = 2L, grad = 200, lims = c(-0.5, 0.5)),
                  RBF_block(res = 1L),
                  RBF_block(res = 2L),
                  LFT(a = c(a,b,c,d)))
    }
    
    nlayers <- length(layers)
    
    eta <- list()
    set.seed(space_seed)
    eta[[1]] <- sin(seq(0, pi, length.out = r1))
    eta[[2]] <- c(1, rep(0, r1-1))
    eta_RBF1 = runif(n = 9, min = -1, max = exp(3/2)/2)
    eta_RBF2 = runif(n = 81, min = -1, max = exp(3/2)/2)
    for(j in 3:92) eta[[j]] <- c(eta_RBF1, eta_RBF2)[j-2]
    # for(j in 3:(92)) eta[[j]] <- runif(n = 1, min = -1, max = exp(3/2)/2)
    
    # swarped <- s
    for(i in 1: (nlayers)){ # nlayers - 1 ???
      if (layers[[i]]$name == "LFT") {
        swarped <- layers[[i]]$fR(swarped, LFT.pmt) %>% scal_0_5_mat()
      } else { swarped <- layers[[i]]$fR(swarped, eta[[i]]) %>% scal_0_5_mat() }
    }
    
    s_in = swarped
  }  else stop("type must be one of 'step2D', 'AWU_RBF_2D', 'AWU_RBF_LFT_2D'")
  
  print("data generating")
  set.seed(data_seed)
  if (model == "AI") {
    D_in = rdist(s_in)
    # exponential covariance with nugget 0, range 1, and sill 1
    # f_true = exp(D_in) %*% matrix(rnorm(nrow(s_in)*trep), nrow = nrow(s_in), ncol = trep)
    f_true = matrix(evd::rgpd(nrow(s_in)*trep, loc=1, scale=1, shape=1), 
                    nrow = nrow(s_in), ncol = trep)
  } else if (model == "MSP-BR") {
    f_true = simulMSP(s_in = s_in, range = phi, dof = kappa, D = as.matrix(dist(swarped)), 
                      Trep = trep, B = 10000)
  } else if (model == "r-Pareto") {
    f_true = simulrPareto(n = trep, loc = data.frame(swarped),
                          range = phi, dof = kappa,
                          D = as.matrix(dist(swarped)),
                          risk = risk, siteindex = siteindex, 
                          nCores = nCores, cl = cl)
  } 
  
  ## SAMPLE DATA
  idx_obs <- sample(1:nrow(s), n_obs)
  sobs <- s[idx_obs, , drop = FALSE]
  y <- data.frame(f_true)[idx_obs,]
  
  # s: sites
  # sobs: sampled sites
  # swarped: warped sites
  # f_true: observed values on all sites
  # y: observed values on sampled sites + noise
  list(s = s,
       sobs = sobs,
       swarped = swarped,
       f_true = f_true,
       y = y,
       phi = phi,
       kappa = kappa,
       LFT.pmt = LFT.pmt,
       eta = eta,
       idx_obs = idx_obs)
}


